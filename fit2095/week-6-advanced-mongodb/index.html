<?xml version="1.0" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><div class="square-box">&#xD;
&#xD;
<strong>Question</strong>: MongoDB is very flexible. It allows me to insert documents in collections with&#xC2;&#xA0;different shapes. But, can I have strongly-typed documents? and&#xC2;&#xA0;is there any way to validate the input data?&#xD;
&#xD;
<strong>Answer</strong>: Using MongooseJS, you can have strongly-typed schemas, data validation, data pre-processing, and many other features.&#xD;
&#xD;
</div>&#xD;
&#xA0;&#xD;
<div class="square-box">&#xD;
&#xD;
<strong>Question</strong>: I am developing a web app that stores books and each book has one Author. How can I create a one to one relationship?&#xD;
&#xD;
</div>&#xD;
<strong>Approach 1</strong>: the first way to do that is to store the author's object as a property of the book&#xD;
&#xD;
For example:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">let Author = {&#xD;
    _id: 1234,&#xD;
    firstName: 'Tim',&#xD;
    lastName: 'John',&#xD;
    age: 35&#xD;
};&#xD;
&#xD;
let book1 = {&#xD;
    _id: 789,&#xD;
    title: 'FIT2095 Book',&#xD;
    author: {&#xD;
        id: 1234,&#xD;
        firstName: 'Tim',&#xD;
        lastName: 'John',&#xD;
        age: 35&#xD;
    },&#xD;
    isbn: 9876&#xD;
}</pre>&#xD;
&#xA0;&#xD;
&#xD;
But this approach has several problems. I have to iterate through all books documents each time I need to update an author.&#xD;
&#xD;
<strong>Approach 2</strong>: Let's save the author's ID as a property of his book.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">let Author = {&#xD;
    _id: 1234,&#xD;
    firstName: 'Tim',&#xD;
    lastName: 'John',&#xD;
    age: 35&#xD;
};&#xD;
&#xD;
let book1 = {&#xD;
    _id: 789,&#xD;
    title: 'FIT2095 Book',&#xD;
    author_id: 1234,&#xD;
    isbn: 9876&#xD;
}</pre>&#xD;
&#xA0;&#xD;
<div class="square-box">&#xD;
&#xD;
<strong>Question</strong>: Is there any tool or package that helps to create such a relation?&#xD;
&#xD;
<strong>Answer</strong>: Yes, Mongoose.&#xD;
&#xD;
</div>&#xD;
&#xA0;&#xD;
<h2>What is Mongoose?</h2>&#xD;
Sources:[2,3,4]&#xD;
&#xD;
<strong>Mongoose</strong> is an object data modelling (ODM) library that provides a modeling environment for your collections. It enforces structure as needed while still keeping the flexibility and scalability of MongoDB.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
<strong>Mongoose</strong> is a JavaScript framework that is commonly used in a Node.js application with a MongoDB database.&#xC2;&#xA0;Mongoose provides a straight-forward, schema-based solution to model your application data. It includes built-in typecasting, validation, query building, business logic hooks and more, out of the box.&#xD;
&#xD;
It uses MongoDB driver to interact with MongoDB storage.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
<a href="https://www.alexandriarepository.org/media/mongoose" rel="attachment wp-att-161251"><img class="wp-image-161251 aligncenter" style="border: black dashed 1px;" src="./assets/mongoose.png" alt="" width="243" height="495"/></a>&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
Mongoose provides an incredible amount of functionality around creating and working with schemas. Mongoose currently contains eight SchemaTypes that a property is saved as when it is persisted to MongoDB. They are:&#xD;
<ol><li>String</li>&#xD;
 	<li>Number</li>&#xD;
 	<li>Date</li>&#xD;
 	<li>Buffer</li>&#xD;
 	<li>Boolean</li>&#xD;
 	<li>Mixed</li>&#xD;
 	<li>ObjectId</li>&#xD;
 	<li>Array</li>&#xD;
 	<li>Decimal128</li>&#xD;
 	<li>Map</li>&#xD;
</ol>&#xD;
&#xA0;&#xD;
&#xD;
SchemaTypes handle definition of path&#xD;
<ol><li>defaults</li>&#xD;
 	<li>validation</li>&#xD;
 	<li>getters</li>&#xD;
 	<li>setters</li>&#xD;
 	<li>field selection defaults for queries</li>&#xD;
</ol>&#xD;
&#xA0;&#xD;
&#xD;
Further to these common options, certain data types allow you to further customize how the data is stored and retrieved from the database. For example, a&#xC2;&#xA0;String&#xC2;&#xA0;data type also allows you to specify the following additional options:&#xD;
<ul><li>convert it to lowercase</li>&#xD;
 	<li>convert it to uppercase</li>&#xD;
 	<li>trim data prior to saving</li>&#xD;
 	<li>a regular expression that can limit data allowed to be saved during the validation process</li>&#xD;
 	<li>an enum that can define a list of strings that are valid</li>&#xD;
</ul>&#xD;
&#xA0;&#xD;
&#xD;
We will discuss them in details soon.&#xD;
<div class="square-box">&#xD;
<h3>In a nutshell, we will use Mongoose functions and options and perform all the CRUD (Create, Retrieve, Update, Delete) operations on MongoDB database.</h3>&#xD;
</div>&#xD;
<h2>Schema in Mongoose</h2>&#xD;
Let's start by creating a database that consists of two collections (Authors and Books). We will implement a simple relationship between them which is One-To-One. In other words, each book has an author.&#xD;
&#xD;
Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.&#xD;
&#xD;
&#xA0;&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">var mongoose = require('mongoose');</pre>&#xD;
Initially, get a reference from Mongoose package&#xD;
&#xD;
Create your&#xC2;&#xA0;schema:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">var authorSchema = mongoose.Schema({});&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now let's add our fields:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">var authorSchema = mongoose.Schema({&#xD;
    _id: mongoose.Schema.Types.ObjectId,&#xD;
    name: {&#xD;
            firstName:String,&#xD;
            lastName:String,&#xD;
           }, &#xD;
    age: Number,&#xD;
    created: Date&#xD;
});</pre>&#xD;
Using the above schema, each document will get four items, which are: _id, name, age, and created.&#xD;
&#xD;
Now, I need to add some roles to my schema:&#xD;
<ul><li>Field name is mandatory (i.e. required)</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">name: {&#xD;
        firstName: {&#xD;
            type: String,&#xD;
            required: true&#xD;
        },&#xD;
        lastName: String&#xD;
    }</pre>&#xD;
<p style="padding-left: 60px;">From the above, to make a field required, set the field an object with two properties: the <strong>type</strong> and <strong>required</strong> which needs a boolean value.</p>&#xD;
&#xA0;&#xD;
<ul><li>Field age should be a number between 10 and 110</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">age: {&#xD;
        type: Number,&#xD;
        validate: {&#xD;
            validator: function (ageValue) {&#xD;
                return ageValue &gt;= 10 &amp;&amp; ageValue &lt;= 110;&#xD;
            },&#xD;
            message: 'Age should be a number between 10 and 110'&#xD;
        }&#xD;
    }</pre>&#xD;
<p style="padding-left: 60px;">Similar to name, age becomes an object with two properties: the type and validate which has a boolean function that takes an input represents the field's (age) value and returns true if the value is valid (based on our logic) and false otherwise.&#xC2;&#xA0; The <strong>message</strong>&#xC2;&#xA0;property is a string represents the output that will be printed out when an invalid value is detected.</p>&#xD;
<p style="padding-left: 60px;">There is another way to validate the minimum and maximum values of numeric fields by using the <strong>min</strong> and <strong>max</strong> properties:</p>&#xD;
&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">age: { type: Number, min: 5, max: 20 }</pre>&#xD;
&#xA0;&#xD;
<ul><li>Field created has a default value</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">created: {&#xD;
    type: Date,&#xD;
    default: Date.now&#xD;
}</pre>&#xD;
<p style="padding-left: 60px;">The field created is an object with two properties: the type and the default value of the field if no value is provided.</p>&#xD;
&#xA0;&#xD;
&#xD;
So, the schema in one piece:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
&#xD;
let authorSchema = mongoose.Schema({&#xD;
    _id: mongoose.Schema.Types.ObjectId,&#xD;
    name: {&#xD;
        firstName: {&#xD;
            type: String,&#xD;
            required: true&#xD;
        },&#xD;
        lastName: String&#xD;
    },&#xD;
    age: {&#xD;
        type: Number,&#xD;
        validate: {&#xD;
            validator: function (ageValue) {&#xD;
                return ageValue &gt;= 10 &amp;&amp; ageValue &lt;= 110;&#xD;
            },&#xD;
            message: 'Age should be a number between 10 and 110'&#xD;
        }&#xD;
    },&#xD;
    created: {&#xD;
        type: Date,&#xD;
        default: Date.now&#xD;
    }&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now its time to create the Book schema, which has to have the following fields: _id (ObjectId), title (String and required), isdn (String), author (ObjectId, reference wit Author Schema), and created(Date with the default value to the current date/time).&#xD;
<ul><li>field <strong>_id</strong>:</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">_id: mongoose.Schema.Types.ObjectId,</pre>&#xD;
<ul><li>field <strong>title:</strong></li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">title: {&#xD;
       type: String,&#xD;
       required: true&#xD;
   },</pre>&#xD;
<ul><li>field&#xC2;&#xA0;<strong>isbn</strong>:</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">isbn: String,&#xD;
</pre>&#xD;
<ul><li>field&#xC2;&#xA0;<strong>author</strong>:</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">author: {&#xD;
        type: mongoose.Schema.Types.ObjectId,&#xD;
        ref: 'Author'&#xD;
    },</pre>&#xD;
<p style="padding-left: 60px;">Field <strong>author</strong> is an object with two properties: <strong>type</strong> and <strong>ref</strong>. The type is ObjectId because it will only have the Id of the author's document. the <strong>ref</strong> indicates the name of the schema, which is, in this case, the <strong>Author</strong>.</p>&#xD;
&#xD;
<ul><li>field <strong>created</strong>:</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">created: {&#xD;
        type: Date,&#xD;
        default: Date.now&#xD;
    }</pre>&#xD;
&#xA0;&#xD;
&#xD;
So, the Book schema in one piece:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
&#xD;
let bookSchema = mongoose.Schema({&#xD;
    _id: mongoose.Schema.Types.ObjectId,&#xD;
    title: {&#xD;
        type: String,&#xD;
        required: true&#xD;
    },&#xD;
    isbn: String,&#xD;
    author: {&#xD;
        type: mongoose.Schema.Types.ObjectId,&#xD;
        ref: 'Author'&#xD;
    },&#xD;
    created: {&#xD;
        type: Date,&#xD;
        default: Date.now&#xD;
    }&#xD;
});</pre>&#xD;
&#xA0;&#xD;
<h2><strong>Mongoose Models</strong></h2>&#xD;
&#xE2;&#x80;&#x98;Models&#xE2;&#x80;&#x99; are higher-order constructors that take a schema and create an instance of a document equivalent to records in a relational database.&#xC2;&#xA0;A Mongoose model is a wrapper on the Mongoose schema. A Mongoose schema defines the structure of the document, default values, validators, etc., whereas a Mongoose model provides an interface to the database for creating, querying, updating, deleting records, etc. [4]&#xD;
&#xD;
So, in order to export a model, we need to invoke the <strong>model</strong> constructor and pass it a string represents <span style="text-decoration: underline;"><strong>the name of the collection</strong></span> and a reference to the schema.&#xD;
&#xD;
For example, the <strong>Author</strong> schema:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
&#xD;
let authorSchema = mongoose.Schema({&#xD;
    _id: mongoose.Schema.Types.ObjectId,&#xD;
    name: {&#xD;
        firstName: {&#xD;
            type: String,&#xD;
            required: true&#xD;
        },&#xD;
        lastName: String&#xD;
    },&#xD;
    age: {&#xD;
        type: Number,&#xD;
        validate: {&#xD;
            validator: function (ageValue) {&#xD;
                return ageValue &gt;= 10 &amp;&amp; ageValue &lt;= 110;&#xD;
            },&#xD;
            message: 'Age should be a number between 10 and 110'&#xD;
        }&#xD;
    },&#xD;
 //   age     : { type: Number, min: 5, max: 20 }, &#xD;
    created: {&#xD;
        type: Date,&#xD;
        default: Date.now&#xD;
    }&#xD;
});&#xD;
&#xD;
module.exports = mongoose.model('Author', authorSchema);&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
and the <strong>Book</strong> model:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">const mongoose = require('mongoose');&#xD;
&#xD;
let bookSchema = mongoose.Schema({&#xD;
    _id: mongoose.Schema.Types.ObjectId,&#xD;
    title: {&#xD;
        type: String,&#xD;
        required: true&#xD;
    },&#xD;
    isbn: String,&#xD;
    author: {&#xD;
        type: mongoose.Schema.Types.ObjectId,&#xD;
        ref: 'Author'&#xD;
    },&#xD;
    created: {&#xD;
        type: Date,&#xD;
        default: Date.now&#xD;
    }&#xD;
});&#xD;
&#xD;
module.exports = mongoose.model('Book', bookSchema);</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now, our database has two collections 'Author' and 'Book'.&#xD;
&#xD;
&#xA0;&#xD;
<h2>Inserting Documents</h2>&#xD;
Now, its time to develop the main app js file and insert new documents into the DB.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
Let's start by referencing Mongoose package&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
referencing our schemas:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const Author = require('./models/author');&#xD;
const Book = require('./models/book');</pre>&#xD;
&#xA0;&#xD;
&#xD;
Create a Mongoose URL string which has syntax: mongodb<strong>://ServerAddress: Port//DbName</strong>&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">let url='mongodb://localhost:27017/libDB';</pre>&#xD;
&#xA0;&#xD;
&#xD;
and then connect&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">mongoose.connect(url, function (err) {});&#xD;
</pre>&#xD;
The <strong>err</strong> parameter will get a value if an error occurs.&#xD;
&#xD;
Let's create a new author:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">let author1 = new Author({&#xD;
    _id: new mongoose.Types.ObjectId(),&#xD;
    name: {&#xD;
        firstName: 'Tim',&#xD;
        lastName: 'John'&#xD;
    },&#xD;
    age: 80&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now, let's save it:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">author1.save(function (err) {});</pre>&#xD;
the save function has a callback that will get executed after the save operation is completed.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
To test the data type validation, try to insert a document where the age is a non-numeric value:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">let author1 = new Author({&#xD;
    _id: new mongoose.Types.ObjectId(),&#xD;
    name: {&#xD;
        firstName: 'Tim',&#xD;
        lastName: 'John'&#xD;
    },&#xD;
    age: '8a'&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Next, I need to add two books for this author (author1 or 'Tim John'):&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">var book1 = new Book({&#xD;
           _id: new mongoose.Types.ObjectId(),&#xD;
           title: 'FIT2095 Book ',&#xD;
           author: author1._id,&#xD;
           isbn: '123456',&#xD;
       });</pre>&#xD;
Line 4, field <strong>author</strong>, which is of type ObjectId and <span style="background-color: #f6d5d9;"><span style="background-color: #ffffff;">referencing&#xC2;&#xA0;</span></span><span style="background-color: #ffffff;">Auth</span>or Schema (look at line 11 in the Book Schema) is set to the ID of the author we have just created (author1).&#xD;
&#xD;
Similar to the author, we have to save the new document by calling the function <strong>save</strong>.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">book1.save(function (err) {&#xD;
    if (err) throw err;&#xD;
    console.log('Book1 successfully Added to DB');&#xD;
});&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
Let's add another book:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">var book2 = new Book({&#xD;
    _id: new mongoose.Types.ObjectId(),&#xD;
    title: 'MEAN Stack with FIT2095',&#xD;
    author: author1._id&#xD;
});</pre>&#xD;
and let's save it&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">book2.save(function (err) {&#xD;
    if (err) throw err;&#xD;
&#xD;
    console.log('Book2 successfully add to DB');&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now, the app.js in one piece:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
&#xD;
const Author = require('./models/author');&#xD;
const Book = require('./models/book');&#xD;
&#xD;
mongoose.connect('mongodb://localhost:27017/libDB', function (err) {&#xD;
    if (err) {&#xD;
        console.log('Error in Mongoose connection');&#xD;
        throw err;&#xD;
    }&#xD;
&#xD;
    console.log('Successfully connected');&#xD;
&#xD;
    let author1 = new Author({&#xD;
        _id: new mongoose.Types.ObjectId(),&#xD;
        name: {&#xD;
            firstName: 'Tim',&#xD;
            lastName: 'John'&#xD;
        },&#xD;
        age: 80&#xD;
    });&#xD;
&#xD;
    author1.save(function (err) {&#xD;
        if (err) throw err;&#xD;
&#xD;
        console.log('Author successfully Added to DB');&#xD;
&#xD;
        var book1 = new Book({&#xD;
            _id: new mongoose.Types.ObjectId(),&#xD;
            title: 'FIT2095 Book ',&#xD;
            author: author1._id,&#xD;
            isbn: '123456',&#xD;
        });&#xD;
&#xD;
        book1.save(function (err) {&#xD;
            if (err) throw err;&#xD;
            console.log('Book1 successfully Added to DB');&#xD;
        });&#xD;
&#xD;
        var book2 = new Book({&#xD;
            _id: new mongoose.Types.ObjectId(),&#xD;
            title: 'MEAN Stack with FIT2095',&#xD;
            author: author1._id&#xD;
        });&#xD;
&#xD;
        book2.save(function (err) {&#xD;
            if (err) throw err;&#xD;
&#xD;
            console.log('Book2 successfully add to DB');&#xD;
        });&#xD;
    });&#xD;
});</pre>&#xD;
&#xA0;&#xD;
<blockquote>Note: the creating and saving of <strong>book1</strong> and <strong>book2</strong> have been implemented insode the callback of <strong>author1.save</strong> function. Why??&#xD;
&#xD;
Node.js is asynchrounus and both <strong>book1</strong> and <strong>book2</strong> required the author's ID (lines 31 and 43). Therefore, we have to create them after the save operation of the author is done.</blockquote>&#xD;
<h3>.insertMany() function</h3>&#xD;
This function takes as input an array of documents (objects) and inserts them if they are valid.&#xD;
&#xD;
&#xA0;&#xD;
<h2>Querying Documents with Mongoose</h2>&#xD;
Mongoose models have several static functions that can be used for CRUD operations.&#xD;
<ul><li>Model.deleteMany()</li>&#xD;
 	<li>Model.deleteOne()</li>&#xD;
 	<li>Model.find()</li>&#xD;
 	<li>Model.findById()</li>&#xD;
 	<li>Model.findByIdAndDelete()</li>&#xD;
 	<li>Model.findByIdAndRemove()</li>&#xD;
 	<li>Model.findByIdAndUpdate()</li>&#xD;
 	<li>Model.findOne()</li>&#xD;
 	<li>Model.findOneAndDelete()</li>&#xD;
 	<li>Model.findOneAndRemove()</li>&#xD;
 	<li>Model.findOneAndUpdate()</li>&#xD;
 	<li>Model.replaceOne()</li>&#xD;
 	<li>Model.updateMany()</li>&#xD;
 	<li>Model.updateOne()</li>&#xD;
</ul>&#xD;
&#xA0;&#xD;
<blockquote>For more details about all the above functions, please navigate to:<a href="https://mongoosejs.com/docs/queries.html">&#xC2;&#xA0;https://mongoosejs.com/docs/queries.html</a></blockquote>&#xD;
&#xA0;&#xD;
<h3>Finding Documents</h3>&#xD;
Simple Query&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">Book.find({ 'name.firstName': 'Tim' }, function (err, docs) {&#xD;
  // docs is an array&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Retrieving only certain fields&#xD;
&#xD;
Example: get the age of all documents with first name = 'Tim'&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">Author.find({ 'name.firstName': 'Tim' }, 'age', function (err, docs) {&#xD;
    //docs is an array&#xD;
    console.log(docs);&#xD;
&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Find only one&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Model.findOne({'name.firstName':'Tim'}, 'age', function (err, doc) {&#xD;
//doc is a document &#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Find by ID&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Author.findById(author1._id, 'age', function (err, docs) {&#xD;
    console.log(docs);&#xD;
});</pre>&#xD;
&#xA0;&#xD;
<h2>Using the 'where' clause</h2>&#xD;
Using 'where', we can create complex expressions.&#xD;
&#xD;
Example: Find all documents that have firstName starts with the letter 'T' and the age &gt;= 25.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Author.where({ 'name.firstName': /^T/ }).where('age').gte(25).exec(function (err, docs) {&#xD;
     console.log(docs);&#xD;
&#xD;
 });</pre>&#xD;
<blockquote>Note <strong>exec</strong> indicates the end of the chain and invokes the callback function.</blockquote>&#xD;
and age &lt;=35&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Author.where({ 'name.firstName': /^T/ }).where('age').gte(25).lte(35).exec(function (err, docs) {&#xD;
    console.log(docs);&#xD;
&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
limit the result to 10 only:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Author.where({ 'name.firstName': /^T/ }).where('age').gte(25).lte(35).limit(10).exec(function (err, docs) {&#xD;
    console.log(docs);&#xD;
&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
and sort the results in ascending order by the <strong>age</strong>&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Author.where({ 'name.firstName': /^T/ }).where('age').gte(25).lte(35).limit(10).sort('age').exec(function (err, docs) {&#xD;
    console.log(docs);&#xD;
&#xD;
});</pre>&#xD;
&#xA0;&#xD;
<h2>Populate</h2>&#xD;
Mongoose has a powerful aggregation operator called populate(), which allows you reference documents in other collections.&#xD;
&#xD;
For exmaple, to get the books and their authors' details:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">Book.find({}).populate('author').exec(function (err, data) {&#xD;
       console.log(data);&#xD;
    });</pre>&#xD;
&#xA0;&#xD;
<h2>Update Documents</h2>&#xD;
<h3>.updateOne() function</h3>&#xD;
This document updates only the first document that matches criteria.&#xD;
&#xD;
&#xA0;&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">Author.updateOne({ 'name.firstName': 'Alex' }, { $set: { 'name.firstName': 'John' } }, function (err, doc) {&#xD;
    console.log(doc);&#xD;
});</pre>&#xD;
&#xA0;&#xD;
<h3>.updateMany() function</h3>&#xD;
Similar to updateOne()&#xC2;&#xA0;except MongoDB will update all the document that matche criteria.&#xD;
&#xD;
&#xA0;&#xD;
<h2>Delete Documents</h2>&#xD;
<h3>.deleteOne() function</h3>&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Author.deleteOne({ 'name.firstName': 'Tim' }, function (err, doc) {&#xD;
    console.log(doc);&#xD;
&#xD;
});</pre>&#xD;
deleteOne() function&#xC2;&#xA0;deletes a document based on condition (criteria).&#xD;
<h3>.deleteMany()</h3>&#xD;
This function deletes all the documents that match the criteria.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">Author.deleteMany({ 'name.firstName': 'Tim' }, function (err, doc) {&#xD;
    console.log(doc);&#xD;
&#xD;
});</pre>&#xD;
&#xA0;&#xD;
<blockquote>The full list of Model's functions can be found here:&#xC2;&#xA0;<a href="https://mongoosejs.com/docs/api.html#Model">https://mongoosejs.com/docs/api.html#Model</a></blockquote>&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
References:&#xD;
<ol><li>https://mongoosejs.com/</li>&#xD;
 	<li>Practical Node.js, Building Real-World Scalable Web Apps [Book]</li>&#xD;
 	<li>https://mongoosejs.com/docs/guide.html</li>&#xD;
 	<li>https://medium.freecodecamp.org/introduction-to-mongoose-for-mongodb-d2a7aa593c57</li>&#xD;
</ol>&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;</body></html>
