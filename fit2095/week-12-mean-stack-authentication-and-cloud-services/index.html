<?xml version="1.0" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><h2>How secure are MEAN stack applications?</h2>&#xD;
MEAN stack applications are becoming popular due to their lightweight, massive ecosystem of middleware plugins and dependencies, and easy to deploy to most cloud vendors. However, these applications might be attacked by common vulnerabilities that are introduced either by using MEAN stack components in their default configurations or due to common developer mistakes.&#xD;
&#xD;
In this section, we will examine one case&#xD;
<h2>Query selector injection (MongoDB)</h2>&#xD;
MongoDB database is vulnerable to an attack called Query Selector Injection that uses Query selector logic operators to change queries.&#xD;
&#xD;
Let's have an example:&#xD;
&#xD;
If a client sends a login request (POST) to a server that consists of a username and password, the intruder can&#xC2;&#xA0;intercept the login request and changed the POST pass parameter to password[$ne]=null where $ne is the MongoDB query operator &#xE2;&#x80;&#x98;not equal to&#xE2;&#x80;&#x99;.&#xD;
&#xD;
When Express processes the x-www-form-urlencoded request body, this will be parsed into the object {username: &#xE2;&#x80;&#x98;admin&#xE2;&#x80;&#x99;, password: {$ne: null} and passed to the MongoDB query:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">db.collection('users').findOne({username:user,password:pass},function(err,result){&#xD;
    if(result!==null){&#xD;
        res.redirect('/')&#xD;
    }else{&#xD;
        res.redirect('/login');&#xD;
    }&#xD;
});</pre>&#xD;
Passing the above object to MongoDB, the query will match the first username that matches &#xE2;&#x80;&#x98;admin&#xE2;&#x80;&#x99; with a password that is not equal to null, allowing us to authenticate to the application as an administrator without providing a valid password.&#xD;
&#xD;
&#xA0;&#xD;
<h3>Mitigation</h3>&#xD;
The simplest way to mitigate query selector injection is to cast the values to a String before running the query.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">db.collection("users").findOne(&#xD;
  {&#xD;
    username: String(user),&#xD;
    password: String(pass),&#xD;
  },&#xD;
  function(err, result) {&#xD;
    if (result !== null) {&#xD;
      res.redirect("/");&#xD;
    } else {&#xD;
      res.redirect("/login");&#xD;
    }&#xD;
  }&#xD;
);</pre>&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
This website contains a very long list of&#xC2;&#xA0;Web Application and Network Vulnerabilities <a href="https://www.acunetix.com/vulnerabilities/web/">CLICK HERE.</a>&#xD;
&#xD;
<hr/><h2>MEAN Stack Authentication</h2>&#xD;
<blockquote>The main source of this section is:<a href="http://www.passportjs.org/docs/">&#xC2;&#xA0;http://www.passportjs.org/docs/</a></blockquote>&#xD;
In modern web applications, authentication can take a variety of forms. Traditionally, users log in by providing a username and password. With the rise of social networking, single sign-on using an OAuth provider such as Facebook or Twitter has become a popular authentication method. Services that expose an API often require token-based credentials to protect access.&#xD;
&#xD;
There are several&#xC2;&#xA0;authentication libraries that can be used to provide user management and authentication such as PassportJS and&#xC2;&#xA0;Everyauth.&#xD;
<blockquote>Note: you can build your own database and a hashing algorithm (for passwords) or you can use&#xC2;&#xA0;User Management as a Service Cloud Services such as&#xC2;&#xA0;<a href="https://www.okta.com/">Okta&#xC2;&#xA0;</a>&#xC2;&#xA0;and <a href="https://www.onelogin.com/">onelogin</a>.</blockquote>&#xD;
In this section, we will use PassportJS as an example for Auth libraries.&#xD;
<h3>What is Passport.js?</h3>&#xD;
Passport is authentication middleware for Node.js. As it&#xE2;&#x80;&#x99;s extremely flexible and modular, Passport can be unobtrusively dropped into any Express-based web application. A comprehensive set of strategies supports authentication using a username and password, Facebook, Twitter, and more. Find out more about Passport here.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
Features&#xD;
<ul><li class="item-1">300+ authentication strategies</li>&#xD;
 	<li class="item-1">Single sign-on with OpenID and OAuth</li>&#xD;
 	<li class="item-1">Easily handle success and failure</li>&#xD;
 	<li class="item-1">Supports persistent sessions</li>&#xD;
 	<li class="item-1">Dynamic scope and permissions</li>&#xD;
 	<li class="item-1">Pick and choose required strategies</li>&#xD;
 	<li class="item-1">Implement custom strategies</li>&#xD;
 	<li class="item-1">Does not mount routes in application</li>&#xD;
 	<li class="item-1">Lightweight code base</li>&#xD;
</ul>&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
Now, we will examine four strategies provided by PassportJS, which are: local, Open ID, Facebook, and Google.&#xD;
<h2>Username &amp; Password (Local)</h2>&#xD;
<p style="padding-left: 60px;">The most widely used way for websites to authenticate users is via a username and password. Support for this mechanism is provided by the passport-local module.</p>&#xD;
&#xD;
<h3 style="padding-left: 60px;">Install</h3>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="shell">npm install passport-local</pre>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">var passport = require('passport')&#xD;
  , LocalStrategy = require('passport-local').Strategy;&#xD;
&#xD;
passport.use(new LocalStrategy(&#xD;
  function(username, password, done) {&#xD;
    User.findOne({ username: username }, function(err, user) {&#xD;
      if (err) { return done(err); }&#xD;
      if (!user) {&#xD;
        return done(null, false, { message: 'Incorrect username.' });&#xD;
      }&#xD;
      if (!user.validPassword(password)) {&#xD;
        return done(null, false, { message: 'Incorrect password.' });&#xD;
      }&#xD;
      return done(null, user);&#xD;
    });&#xD;
  }&#xD;
));</pre>&#xD;
<p style="padding-left: 60px;">The verify callback for local authentication accepts username and password arguments, which are submitted to the application via a login form.</p>&#xD;
&#xD;
<h3 style="padding-left: 60px;">Parameters</h3>&#xD;
<p style="padding-left: 60px;">By default, LocalStrategy expects to find credentials in parameters named username and password. If your site prefers to name these fields differently, options are available to change the defaults.</p>&#xD;
&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">passport.use(new LocalStrategy({&#xD;
    usernameField: 'email',&#xD;
    passwordField: 'passwd'&#xD;
  },&#xD;
  function(username, password, done) {&#xD;
    // ...&#xD;
  }&#xD;
));</pre>&#xD;
<h3 style="padding-left: 60px;">Route</h3>&#xD;
<p style="padding-left: 60px;">The login form is submitted to the server via the POST method. Using authenticate() with the local strategy will handle the login request.</p>&#xD;
&#xD;
<h2/>&#xD;
<h2>OpenID</h2>&#xD;
<p style="padding-left: 60px;">OpenID is an open standard for federated authentication. When visiting a website, users present their OpenID to sign in. The user then authenticates with their chosen OpenID provider, which issues an assertion to confirm the user's identity. The website verifies this assertion in order to sign the user in.</p>&#xD;
&#xD;
<h3 style="padding-left: 60px;">Install</h3>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="null">npm install passport-openid</pre>&#xD;
<h2 style="padding-left: 60px;">Configuration</h2>&#xD;
<p style="padding-left: 60px;">When using OpenID, a return URL and realm must be specified. The returnURL is the URL to which the user will be redirected after authenticating with their OpenID provider. realm indicates the part of URL-space for which authentication is valid. Typically this will be the root URL of the website.</p>&#xD;
&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">var passport = require('passport')&#xD;
  , OpenIDStrategy = require('passport-openid').Strategy;&#xD;
&#xD;
passport.use(new OpenIDStrategy({&#xD;
    returnURL: 'http://www.example.com/auth/openid/return',&#xD;
    realm: 'http://www.example.com/'&#xD;
  },&#xD;
  function(identifier, done) {&#xD;
    User.findOrCreate({ openId: identifier }, function(err, user) {&#xD;
      done(err, user);&#xD;
    });&#xD;
  }&#xD;
));</pre>&#xD;
<h2/>&#xD;
<h2>Facebook</h2>&#xD;
<p style="padding-left: 60px;">The Facebook strategy allows users to log in to a web application using their Facebook account. Internally, Facebook authentication works using OAuth 2.0.</p>&#xD;
&#xD;
<h3 style="padding-left: 60px;">Install</h3>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="null">npm install passport-facebook</pre>&#xD;
<h3 style="padding-left: 60px;">Configuration</h3>&#xD;
<p style="padding-left: 60px;">In order to use Facebook authentication, you must first create an app at Facebook Developers. When created, an app is assigned an App ID and App Secret. Your application must also implement a redirect URL, to which Facebook will redirect users after they have approved access for your application.</p>&#xD;
&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">var passport = require('passport')&#xD;
  , FacebookStrategy = require('passport-facebook').Strategy;&#xD;
&#xD;
passport.use(new FacebookStrategy({&#xD;
    clientID: FACEBOOK_APP_ID,&#xD;
    clientSecret: FACEBOOK_APP_SECRET,&#xD;
    callbackURL: "http://www.example.com/auth/facebook/callback"&#xD;
  },&#xD;
  function(accessToken, refreshToken, profile, done) {&#xD;
    User.findOrCreate(..., function(err, user) {&#xD;
      if (err) { return done(err); }&#xD;
      done(null, user);&#xD;
    });&#xD;
  }&#xD;
));</pre>&#xD;
<h3 style="padding-left: 60px;">Routes</h3>&#xD;
<p style="padding-left: 60px;">Two routes are required for Facebook authentication. The first route redirects the user to Facebook. The second route is the URL to which Facebook will redirect the user after they have logged in.</p>&#xD;
&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">// Redirect the user to Facebook for authentication.  When complete,&#xD;
// Facebook will redirect the user back to the application at&#xD;
//     /auth/facebook/callback&#xD;
app.get('/auth/facebook', passport.authenticate('facebook'));&#xD;
&#xD;
// Facebook will redirect the user to this URL after approval.  Finish the&#xD;
// authentication process by attempting to obtain an access token.  If&#xD;
// access was granted, the user will be logged in.  Otherwise,&#xD;
// authentication has failed.&#xD;
app.get('/auth/facebook/callback',&#xD;
  passport.authenticate('facebook', { successRedirect: '/',&#xD;
                                      failureRedirect: '/login' }));&#xD;
</pre>&#xD;
<h2/>&#xD;
<h2>Google</h2>&#xD;
<p style="padding-left: 60px;">The Google strategy allows users to sign in to a web application using their Google account. Google used to support OpenID internally, but it now works based on OpenID Connect and supports oAuth 1.0 and oAuth 2.0.</p>&#xD;
&#xD;
<h3 style="padding-left: 60px;">Install</h3>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="shell">npm install passport-google-oauth</pre>&#xD;
<h3 style="padding-left: 60px;">Configuration</h3>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">var passport = require('passport');&#xD;
var GoogleStrategy = require('passport-google-oauth').OAuth2Strategy;&#xD;
&#xD;
// Use the GoogleStrategy within Passport.&#xD;
//   Strategies in Passport require a `verify` function, which accept&#xD;
//   credentials (in this case, an accessToken, refreshToken, and Google&#xD;
//   profile), and invoke a callback with a user object.&#xD;
passport.use(new GoogleStrategy({&#xD;
    clientID: GOOGLE_CLIENT_ID,&#xD;
    clientSecret: GOOGLE_CLIENT_SECRET,&#xD;
    callbackURL: "http://www.example.com/auth/google/callback"&#xD;
  },&#xD;
  function(accessToken, refreshToken, profile, done) {&#xD;
       User.findOrCreate({ googleId: profile.id }, function (err, user) {&#xD;
         return done(err, user);&#xD;
       });&#xD;
  }&#xD;
));</pre>&#xD;
<h3 style="padding-left: 60px;">Routes</h3>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">// GET /auth/google&#xD;
//   Use passport.authenticate() as route middleware to authenticate the&#xD;
//   request.  The first step in Google authentication will involve&#xD;
//   redirecting the user to google.com.  After authorization, Google&#xD;
//   will redirect the user back to this application at /auth/google/callback&#xD;
app.get('/auth/google',&#xD;
  passport.authenticate('google', { scope: ['https://www.googleapis.com/auth/plus.login'] }));&#xD;
&#xD;
// GET /auth/google/callback&#xD;
//   Use passport.authenticate() as route middleware to authenticate the&#xD;
//   request.  If authentication fails, the user will be redirected back to the&#xD;
//   login page.  Otherwise, the primary route function function will be called,&#xD;
//   which, in this example, will redirect the user to the home page.&#xD;
app.get('/auth/google/callback', &#xD;
  passport.authenticate('google', { failureRedirect: '/login' }),&#xD;
  function(req, res) {&#xD;
    res.redirect('/');&#xD;
  });</pre>&#xD;
&#xD;
<hr/><h2>Cloud Services</h2>&#xD;
In addition to text to speech service we have covered in the previous week, this section demonstrates two cloud services that can be used to build smart and pervasive applications.&#xD;
<h2>Cloud Storage</h2>&#xD;
In order to make it easier for developers to build scalable and pervasive applications, moving their data to the cloud is one of the options. Regardless of the weak point of being less secure,&#xC2;&#xA0; cloud storage has better flexibility and reliability.&#xC2;&#xA0; There are many cloud vendors that offer cloud storages such as:&#xD;
<ul><li>Rackspace Cloud Storage</li>&#xD;
 	<li>MS Azure Cloud Services on Windows Azure</li>&#xD;
 	<li>Google Firebase</li>&#xD;
 	<li>Zadara</li>&#xD;
 	<li>Cloudian</li>&#xD;
</ul>&#xD;
&#xA0;&#xD;
<h3>Google Firebase</h3>&#xD;
Cloud Storage for Firebase stores your data in Google Cloud Storage, an exabyte scale object storage solution with high availability and global redundancy. Firebase Admin SDK allows you to directly access your Google Cloud Storage buckets from privileged environments. Then you can use Google Cloud Storage APIs to manipulate the objects stored in the buckets.&#xD;
&#xD;
Google&#xC2;&#xA0;Realtime Database is an efficient, low-latency solution for mobile apps that require synced states across clients in realtime.&#xD;
&#xD;
[embed]https://www.youtube.com/watch?list=PLl-K7zZEsYLmOF_07IayrTntevxtbUxDL&amp;time_continue=54&amp;v=iosNuIdQoy8[/embed]&#xD;
<h3 style="padding-left: 30px;">Receive Messages</h3>&#xD;
<p style="padding-left: 60px;">To receive a message from Google firebase storage, you have to listen to events such as 'child_added' which will be triggered with each new object added to the storage.</p>&#xD;
&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">var callback = function(snap) {&#xD;
  var data = snap.val();&#xD;
  displayMessage(snap.key, data.name, data.text, data.profilePicUrl, data.imageUrl);&#xD;
};&#xD;
&#xD;
firebase.database().ref('/messages/').limitToLast(12).on('child_added', callback);</pre>&#xD;
<p style="padding-left: 30px;">In the above code, '/messages/' is the table's (i.e. collection) name and 'firebase' is a reference to the firebase client. The callback function will be able to access the new object using its input paramter 'snap'.</p>&#xD;
&#xD;
<h3 style="padding-left: 30px;">Send Messages</h3>&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">// Saves a new message on the Firebase DB.&#xD;
function saveMessage(messageText) {&#xD;
  // Add a new message entry to the Firebase Database.&#xD;
  return firebase.database().ref('/messages/').push({&#xD;
    name: getUserName(),&#xD;
    text: messageText,&#xD;
    profilePicUrl: getProfilePicUrl()&#xD;
  }).catch(function(error) {&#xD;
    console.error('Error writing new message to Firebase Database', error);&#xD;
  });&#xD;
}</pre>&#xD;
<p style="padding-left: 60px;">the above code pushes a JSON object to the cloud storage.</p>&#xD;
<p style="padding-left: 60px;">Reference:&#xC2;&#xA0;<a href="https://codelabs.developers.google.com/codelabs/firebase-web/#0">https://codelabs.developers.google.com/codelabs/firebase-web/#0</a></p>&#xD;
&#xD;
<h2/>&#xD;
<h2>Amazon Web Services</h2>&#xD;
Amazon Web Services offers a broad set of global cloud-based products including compute, storage, databases, analytics, networking, mobile, developer tools, management tools, IoT, security and enterprise applications. These services help organizations move faster, lower IT costs, and scale. AWS is trusted by the largest enterprises and the hottest start-ups to power a wide variety of workloads including: web and mobile applications, game development, data processing and warehousing, storage, archive, and many others.&#xD;
&#xD;
&#xA0;&#xD;
<h3>Amazon Rekognition</h3>&#xD;
Amazon Rekognition makes it easy to add image and video analysis to your applications. You just provide an image or video to the Rekognition API, and the service can identify the objects, people, text, scenes, and activities, as well as detect any inappropriate content. Amazon Rekognition also provides highly accurate facial analysis and facial recognition on images and video that you provide. You can detect, analyze, and compare faces for a wide variety of user verification, people counting, and public safety use cases.&#xD;
<h3>Key Features</h3>&#xD;
<ul><li>Object, scene, and activity detection</li>&#xD;
</ul><p style="padding-left: 30px;"><img class="" src="https://d1.awsstatic.com/product-marketing/Rekognition/Label-detection.b3858b2903ec631bef4603b6689848ed342a4400.png" alt="Object, scene, and activity detection" width="512" height="276"/></p>&#xD;
&#xA0;&#xD;
<ul><li>Facial recognition</li>&#xD;
</ul><p style="padding-left: 30px;"><img class="" src="https://d1.awsstatic.com/product-marketing/Rekognition/Image%20for%20facial%20recognition.d14cf0759b26beed0e9731c93a4680954baf7310.jpg" alt="Facial recognition" width="523" height="282"/></p>&#xD;
&#xA0;&#xD;
<ul><li>Facial analysis</li>&#xD;
</ul><p style="padding-left: 30px;"><img class="" src="https://d1.awsstatic.com/product-marketing/Rekognition/Image%20for%20facial%20analysis.3fcc22e8451b4a238540128cb5510b8cbe22da51.jpg" alt="Facial analysis" width="493" height="266"/></p>&#xD;
&#xA0;&#xD;
<ul><li>Text in images</li>&#xD;
</ul><p style="padding-left: 30px;"><img class="" src="https://d1.awsstatic.com/FPO%20Images/text_in_image_on_website_napkin_words.c95f79e666b67737b3e5ec1eaa1c451a6210aa3f.png" alt="Text in images" width="489" height="264"/></p>&#xD;
&#xA0;&#xD;
<p style="padding-left: 60px;">The following piece of code shows how simple and easy comparing two images is.</p>&#xD;
&#xD;
<pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">/* This operation compares the largest face detected in the source image with each face detected in the target image. */&#xD;
&#xD;
 var params = {&#xD;
  SimilarityThreshold: 90, &#xD;
  SourceImage: {&#xD;
   S3Object: {&#xD;
    Bucket: "mybucket", &#xD;
    Name: "mysourceimage"&#xD;
   }&#xD;
  }, &#xD;
  TargetImage: {&#xD;
   S3Object: {&#xD;
    Bucket: "mybucket", &#xD;
    Name: "mytargetimage"&#xD;
   }&#xD;
  }&#xD;
 };&#xD;
 rekognition.compareFaces(params, function(err, data) {&#xD;
   if (err) console.log(err, err.stack); // an error occurred&#xD;
   else     console.log(data);           // successful response&#xD;
   /*&#xD;
   data = {&#xD;
    FaceMatches: [&#xD;
       {&#xD;
      Face: {&#xD;
       BoundingBox: {&#xD;
        Height: 0.33481481671333313, &#xD;
        Left: 0.31888890266418457, &#xD;
        Top: 0.4933333396911621, &#xD;
        Width: 0.25&#xD;
       }, &#xD;
       Confidence: 99.9991226196289&#xD;
      }, &#xD;
      Similarity: 100&#xD;
     }&#xD;
    ], &#xD;
    SourceImageFace: {&#xD;
     BoundingBox: {&#xD;
      Height: 0.33481481671333313, &#xD;
      Left: 0.31888890266418457, &#xD;
      Top: 0.4933333396911621, &#xD;
      Width: 0.25&#xD;
     }, &#xD;
     Confidence: 99.9991226196289&#xD;
    }&#xD;
   }&#xD;
   */&#xD;
 });</pre>&#xD;
&#xA0;&#xD;
&#xD;
References:&#xD;
<ul><li><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Rekognition.html">https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Rekognition.html</a></li>&#xD;
 	<li><a href="https://aws.amazon.com/products/">https://aws.amazon.com/products/</a></li>&#xD;
 	<li><a href="https://www.acunetix.com/vulnerabilities/web/mongodb-injection/">https://www.acunetix.com/vulnerabilities/web/mongodb-injection/</a></li>&#xD;
 	<li><a href="https://medium.com/@SW_Integrity/mongodb-preventing-common-vulnerabilities-in-the-mean-stack-ac27c97198ec">https://medium.com/@SW_Integrity/mongodb-preventing-common-vulnerabilities-in-the-mean-stack-ac27c97198ec</a></li>&#xD;
</ul><h5><em>Note: A non-trivial amount of text and codes from Google, Amazon, and Passport websites have been used this week.</em></h5></body></html>
