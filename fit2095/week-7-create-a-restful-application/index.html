<?xml version="1.0" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<?xml version="1.0" standalone="yes"??>
<html><body><h2>What is RESTFul API?</h2>&#xD;
RESTFul API is an application programming interface that uses&#xC2;&#xA0;HTTP requests to perform the four CRUD operations (Create, Retrieve, Update, Delete) on data.&#xC2;&#xA0; REST stands for Representational State Transfer.&#xC2;&#xA0; It is a stateless architecture (i.e. no information is retained by either sender or receiver) that uses the Web's existing protocols and technologies.&#xD;
&#xD;
The REST architecture consists of:&#xD;
<ul><li>clients</li>&#xD;
 	<li>servers</li>&#xD;
 	<li>resources</li>&#xD;
 	<li>a vocabulary of HTTP operations known as request methods (such as GET, PUT, or DELETE).</li>&#xD;
</ul>&#xD;
&#xA0;&#xD;
<h3>Benefits of REST</h3>&#xD;
<ul><li>The separation between the client and the server</li>&#xD;
 	<li>The REST API is always independent of the type of platform or languages.&#xD;
<ul><li>With REST, data that is produced and consumed is separated from the technologies that facilitate production and consumption. As a result, REST performs well, is highly scalable, simple, and easy to modify and extend</li>&#xD;
</ul></li>&#xD;
 	<li>Since REST is based on standard HTTP operations, it uses verbs with specific meanings such as "get" or "delete" which avoids ambiguity. Resources are assigned individual URIs, adding flexibility.</li>&#xD;
</ul>&#xD;
The following diagram depicts the RESTEFul architecture that consists of a set of different types of clients sending requests and receiving responses from a RESTFul API server which is in turn connected to a database (such as MongoDB).&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
<a href="https://www.alexandriarepository.org/media/restful-system" rel="attachment wp-att-161580"><img class="wp-image-161580 aligncenter" style="border: dashed black 1px;" src="./assets/restful-system.png" alt="" width="475" height="458"/></a>&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
<h2>HTTP methods</h2>&#xD;
HTTP has defined a set of methods which indicates the type of action to be performed on the resources.&#xD;
<ul><li><span style="text-decoration: underline;"><strong>GET</strong> </span>method requests data from the resource and should not produce any side effect.&#xD;
E.g <strong>GET /actors</strong> returns&#xC2;&#xA0;the&#xC2;&#xA0;list of all actors.</li>&#xD;
 	<li><span style="text-decoration: underline;"><strong>POST</strong> </span>method requests the server to create a resource in the database, mostly when a web form is submitted.&#xD;
E.g <strong>POST /movies</strong> creates a new movie where the movies property could be in the body of the request.&#xD;
<strong>POST</strong> is non-idempotent which means multiple requests will have different effects.</li>&#xD;
 	<li><span style="text-decoration: underline;"><strong>PUT</strong> </span>method requests the server to update a resource or create the resource if it doesn&#xE2;&#x80;&#x99;t exist.&#xD;
E.g. PUT /movie/23 will request the server to update, or create if doesn&#xE2;&#x80;&#x99;t exist, the movie with id =23.&#xD;
<strong>PUT</strong> is idempotent which means multiple requests will have the same effects.</li>&#xD;
 	<li><span style="text-decoration: underline;"><strong>DELETE</strong> </span>method requests that the resources, or its instance, should be removed from the database.&#xD;
E.g DELETE /actors/103 will request the server to delete an actor with ID=103 from the actor's collection.</li>&#xD;
</ul>&#xD;
&#xA0;&#xD;
<h2>HTTP response status codes</h2>&#xD;
When the client sends an HTTP request to the server, the client should get feedback, whether it passed, or failed.&#xD;
&#xD;
HTTP status codes are a set of standardized codes which has various explanations in various scenarios.&#xC2;&#xA0; For example:&#xD;
<ul><li>Successful responses&#xD;
<ul><li>200 OK</li>&#xD;
 	<li>201 Created</li>&#xD;
 	<li>202 Accepted</li>&#xD;
</ul></li>&#xD;
 	<li>Client error responses&#xD;
<ul><li>400 Bad Request</li>&#xD;
 	<li>404 Not Found</li>&#xD;
 	<li>405 Method Not Allowed</li>&#xD;
</ul></li>&#xD;
 	<li>Server error responses&#xD;
<ul><li>500 Internal Server Error</li>&#xD;
 	<li>501 Not Implemented</li>&#xD;
 	<li>503 Service Unavailable</li>&#xD;
</ul></li>&#xD;
</ul>&#xD;
The full list of status codes can be found <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HERE</a>.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
<div class="square-box">&#xD;
&#xD;
Develop an application that represents a library for Movies.&#xC2;&#xA0; You have to be able to add, update, retrieve, and delete data.&#xD;
&#xD;
Each movie has:&#xD;
<ul><li>id</li>&#xD;
 	<li>title</li>&#xD;
 	<li>year</li>&#xD;
 	<li>list of actors</li>&#xD;
</ul>&#xD;
Each actor has:&#xD;
<ul><li>id</li>&#xD;
 	<li>name</li>&#xD;
 	<li>birth year</li>&#xD;
 	<li>list of movies</li>&#xD;
</ul>&#xD;
Each&#xC2;&#xA0;movie may have one or more actors, and each actor may have participated in multiple movies.&#xC2;&#xA0;&#xC2;&#xA0;In this case, you have many movies related to many actors (many to many relationships).&#xD;
&#xD;
The server has to respond with status codes:&#xD;
<ul><li>400 if an error occurs</li>&#xD;
 	<li>404 if no document can be found</li>&#xD;
 	<li>200 (which is the default) if the request is processed successfully</li>&#xD;
</ul></div>&#xD;
&#xA0;&#xD;
&#xD;
The structure of the app will be:&#xD;
&#xD;
<a href="https://www.alexandriarepository.org/media/project_explorer" rel="attachment wp-att-161578"><img class="alignnone size-full wp-image-161578" src="./assets/project_explorer.png" alt="" width="295" height="264"/></a>&#xD;
&#xD;
&#xA0;&#xD;
<h3>The Actor schema</h3>&#xD;
&#xA0;&#xD;
&#xD;
The schema needs access to mongoose library:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
Create a new schema&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const actorSchema = new mongoose.Schema({});&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
Declare the ID of each actor (_id)&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">_id: mongoose.Schema.Types.ObjectId,&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
the name is a mandatory field of type string&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">name: {&#xD;
    type: String,&#xD;
    required: true&#xD;
},</pre>&#xD;
&#xA0;&#xD;
&#xD;
the birth year is a mandatory field of type Integer&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">bYear: {&#xD;
       validate: {&#xD;
           validator: function (newYear) {&#xD;
               if (Number.isInteger(newYear))&#xD;
                   return true;&#xD;
               else return false&#xD;
           },&#xD;
           message: 'Birth year should be integer'&#xD;
       },&#xD;
       type: Number,&#xD;
       required: true&#xD;
&#xD;
   },</pre>&#xD;
The validator is a boolean function that returns true if the birth year is integer and false otherwise.&#xD;
&#xD;
In a simpler way, we can code it:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">bYear: {&#xD;
    validate: {&#xD;
        validator: Number.isInteger,&#xD;
        message: 'Birth year should be integer'&#xD;
    },&#xD;
    type: Number,&#xD;
    required: true&#xD;
&#xD;
}</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now, let's&#xC2;&#xA0;define the list of moves, which is an array of references&#xC2;&#xA0;(i.e. ids) to 'Movie' collection&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">movies: [{&#xD;
    type: mongoose.Schema.ObjectId,&#xD;
    ref: 'Movie'&#xD;
}]</pre>&#xD;
&#xA0;&#xD;
&#xD;
The last step is to export the model that uses the above schema.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">module.exports = mongoose.model('Actor', actorSchema);</pre>&#xD;
&#xA0;&#xD;
&#xD;
The Actor Schema ('/models/actor.js) in one piece:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
&#xD;
const actorSchema = new mongoose.Schema({&#xD;
    _id: mongoose.Schema.Types.ObjectId,&#xD;
    name: {&#xD;
        type: String,&#xD;
        required: true&#xD;
    },&#xD;
    bYear: {&#xD;
        validate: {&#xD;
            validator: function (newAge) {&#xD;
                if (Number.isInteger(newAge))&#xD;
                    return true;&#xD;
                else return false&#xD;
            },&#xD;
            message: 'Birth year should be integer'&#xD;
        },&#xD;
        type: Number,&#xD;
        required: true&#xD;
&#xD;
    },&#xD;
    movies: [{&#xD;
        type: mongoose.Schema.ObjectId,&#xD;
        ref: 'Movie'&#xD;
    }]&#xD;
});&#xD;
module.exports = mongoose.model('Actor', actorSchema);</pre>&#xD;
The name of the model is 'Actor', therefore, mongoose will create a collection named 'actors'.&#xD;
<h2>The Movie Schema</h2>&#xD;
The movie Schema ('/models/movie.js') is pretty similar to Actor.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">const mongoose = require('mongoose');&#xD;
&#xD;
const movieSchema = new mongoose.Schema({&#xD;
    _id: mongoose.Schema.Types.ObjectId,&#xD;
    title: {&#xD;
        type: String,&#xD;
        required: true&#xD;
    },&#xD;
    year: {&#xD;
        type: Number,&#xD;
        required: true&#xD;
    },&#xD;
    actors: [{&#xD;
        type: mongoose.Schema.ObjectId,&#xD;
        ref: 'Actor'&#xD;
    }]&#xD;
});&#xD;
&#xD;
module.exports = mongoose.model('Movie', movieSchema);</pre>&#xD;
The name of the model is 'Movies', therefore, mongoose will create a collection named 'movies'.&#xD;
&#xD;
Lines 13-17 define actors, which is an array of references (i.e. ids) to Actor collection. By doing so, each movie document can reference a set of Actors.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
To have better management&#xC2;&#xA0;and to apply the Separation of Concerns principle, two routers for actors and movies will be implemented.&#xD;
<h2>The Actor Router</h2>&#xD;
In this file, all the operation of the 'Actor' collection will be implemented.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
Firstly, the router needs access to both models (Actor and Movie) and to the Mongoose library.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
&#xD;
const Actor = require('../models/actor');&#xD;
const Movie = require('../models/movie');</pre>&#xD;
&#xA0;&#xD;
&#xD;
Next, due to having more than one function to be exported, the router will export an object where each function is a member (property) of that object.&#xD;
&#xD;
&#xA0;&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">module.exports = {&#xD;
// Implement your functions&#xD;
}</pre>&#xD;
&#xA0;&#xD;
&#xD;
<strong>getAll</strong>: is a function that retrieves&#xC2;&#xA0;all the documents from the Actor collection and sends them back as a response.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">getAll: function (req, res) {&#xD;
    Actor.find(function (err, actors) {&#xD;
        if (err) {&#xD;
            return res.json(err);&#xD;
        } else {&#xD;
            res.json(actors);&#xD;
        }&#xD;
    });&#xD;
},</pre>&#xD;
<blockquote>res.json() function sends the response in a JSON format.&#xC2;&#xA0; More details:&#xC2;&#xA0;<a href="https://expressjs.com/en/api.html#res.json">https://expressjs.com/en/api.html#res.json</a></blockquote>&#xD;
<strong>createOne</strong>: is a function that creates a new document based on the parsed data in 'req.body' and saves it in 'Actor' collection.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">createOne: function (req, res) {&#xD;
    let newActorDetails = req.body;&#xD;
    newActorDetails._id = new mongoose.Types.ObjectId();&#xD;
&#xD;
    let actor = new Actor(newActorDetails);&#xD;
    actor.save(function (err) {&#xD;
        console.log('Done');&#xD;
        res.json(actor);&#xD;
    });&#xD;
},</pre>&#xD;
&#xA0;&#xD;
&#xD;
There is another way to insert a new document into a collection by using 'Model.create' function:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">createOne: function (req, res) {&#xD;
    let newActorDetails = req.body;&#xD;
    newActorDetails._id = new mongoose.Types.ObjectId();&#xD;
&#xD;
    Actor.create(newActorDetails, function (err, actor) {&#xD;
        if (err)&#xD;
            return res.json(err);&#xD;
        res.json(actor);&#xD;
    });&#xD;
},</pre>&#xD;
&#xA0;&#xD;
&#xD;
<strong>getOne</strong>: this function finds one document by an ID&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">getOne: function (req, res) {&#xD;
    Actor.findOne({ _id: req.params.id })&#xD;
        .populate('movies')&#xD;
        .exec(function (err, actor) {&#xD;
            if (err) return res.json(err);&#xD;
            if (!actor) return res.json();&#xD;
            res.json(actor);&#xD;
        });&#xD;
},</pre>&#xD;
<blockquote>.populate replaces each ID in the array 'movies' with its document.&#xD;
&#xD;
For example, if there is an actor with two movies, then the output of the above function will be:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="json">{&#xD;
    "movies": [&#xD;
        {&#xD;
            "actors": [],&#xD;
            "_id": "5b89971ce7ef9220bcada5c2",&#xD;
            "title": "FIT2095",&#xD;
            "year": 2015,&#xD;
            "__v": 0&#xD;
        },&#xD;
        {&#xD;
            "actors": [],&#xD;
            "_id": "5b8997c4e7ef9220bcada5c3",&#xD;
            "title": "FIT1051",&#xD;
            "year": 2020,&#xD;
            "__v": 0&#xD;
        }&#xD;
    ],&#xD;
    "_id": "5b89692872b3510c78aa14f2",&#xD;
    "name": "Tim",&#xD;
    "bYear": 2013,&#xD;
    "__v": 2&#xD;
}</pre>&#xD;
But if we omit function populate('movies'), the output will be:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="json">{&#xD;
    "movies": [&#xD;
        "5b89971ce7ef9220bcada5c2",&#xD;
        "5b8997c4e7ef9220bcada5c3"&#xD;
    ],&#xD;
    "_id": "5b89692872b3510c78aa14f2",&#xD;
    "name": "Tim",&#xD;
    "bYear": 2013,&#xD;
    "__v": 2&#xD;
}</pre>&#xD;
More details, please navigate to:<a href="https://mongoosejs.com/docs/populate.html">&#xC2;&#xA0;https://mongoosejs.com/docs/populate.html</a></blockquote>&#xD;
<strong>UpdateOne</strong>: this function finds a document by its ID and sets new content that is retrieved&#xC2;&#xA0;from 'req.body'&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">updateOne: function (req, res) {&#xD;
    Actor.findOneAndUpdate({ _id: req.params.id }, req.body, function (err, actor) {&#xD;
        if (err) return res.status(400).json(err);&#xD;
        if (!actor) return res.status(404).json();&#xD;
&#xD;
        res.json(actor);&#xD;
    });&#xD;
},</pre>&#xD;
&#xA0;&#xD;
<div>&#xD;
<div><strong>deleteOne</strong>: this function deletes the document that matches the criteria.</div>&#xD;
</div>&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">deleteOne: function (req, res) {&#xD;
    Actor.findOneAndRemove({ _id: req.params.id }, function (err) {&#xD;
        if (err) return res.status(400).json(err);&#xD;
&#xD;
        res.json();&#xD;
    });&#xD;
},</pre>&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
<strong>AddMovie</strong>: this function adds a movie ID to the list of movies in an actor's document.&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">addMovie: function (req, res) {&#xD;
    Actor.findOne({ _id: req.params.id }, function (err, actor) {&#xD;
        if (err) return res.status(400).json(err);&#xD;
        if (!actor) return res.status(404).json();&#xD;
&#xD;
        Movie.findOne({ _id: req.body.id }, function (err, movie) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
            if (!movie) return res.status(404).json();&#xD;
&#xD;
            actor.movies.push(movie._id);&#xD;
            actor.save(function (err) {&#xD;
                if (err) return res.status(500).json(err);&#xD;
&#xD;
                res.json(actor);&#xD;
            });&#xD;
        })&#xD;
    });&#xD;
},</pre>&#xD;
The first step is to retrieve the actor's document (line 2)&#xC2;&#xA0; where the id can be found in the URL's params.&#xC2;&#xA0; The next step is to retrieve the movie (line 6) where its ID is saved in the 'req.body'. After pushing the movie into the actor's document, we save (line 11) it back to the database.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
The actor router './routers/actor.js' in&#xC2;&#xA0; one piece:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const mongoose = require('mongoose');&#xD;
&#xD;
const Actor = require('../models/actor');&#xD;
const Movie = require('../models/movie');&#xD;
&#xD;
module.exports = {&#xD;
&#xD;
    getAll: function (req, res) {&#xD;
        Actor.find(function (err, actors) {&#xD;
            if (err) {&#xD;
                return res.status(404).json(err);&#xD;
            } else {&#xD;
                res.json(actors);&#xD;
            }&#xD;
        });&#xD;
    },&#xD;
&#xD;
    createOne: function (req, res) {&#xD;
        let newActorDetails = req.body;&#xD;
        newActorDetails._id = new mongoose.Types.ObjectId();&#xD;
&#xD;
        let actor = new Actor(newActorDetails);&#xD;
        actor.save(function (err) {&#xD;
            res.json(actor);&#xD;
        });&#xD;
    },&#xD;
&#xD;
    getOne: function (req, res) {&#xD;
        Actor.findOne({ _id: req.params.id })&#xD;
            .populate('movies')&#xD;
            .exec(function (err, actor) {&#xD;
                if (err) return res.status(400).json(err);&#xD;
                if (!actor) return res.status(404).json();&#xD;
                res.json(actor);&#xD;
            });&#xD;
    },&#xD;
&#xD;
&#xD;
    updateOne: function (req, res) {&#xD;
        Actor.findOneAndUpdate({ _id: req.params.id }, req.body, function (err, actor) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
            if (!actor) return res.status(404).json();&#xD;
&#xD;
            res.json(actor);&#xD;
        });&#xD;
    },&#xD;
&#xD;
&#xD;
    deleteOne: function (req, res) {&#xD;
        Actor.findOneAndRemove({ _id: req.params.id }, function (err) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
&#xD;
            res.json();&#xD;
        });&#xD;
    },&#xD;
&#xD;
&#xD;
    addMovie: function (req, res) {&#xD;
        Actor.findOne({ _id: req.params.id }, function (err, actor) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
            if (!actor) return res.status(404).json();&#xD;
&#xD;
            Movie.findOne({ _id: req.body.id }, function (err, movie) {&#xD;
                if (err) return res.status(400).json(err);&#xD;
                if (!movie) return res.status(404).json();&#xD;
&#xD;
                actor.movies.push(movie._id);&#xD;
                actor.save(function (err) {&#xD;
                    if (err) return res.status(500).json(err);&#xD;
&#xD;
                    res.json(actor);&#xD;
                });&#xD;
            })&#xD;
        });&#xD;
    }&#xD;
};</pre>&#xD;
&#xA0;&#xD;
<h2>Movie Router</h2>&#xD;
This router is pretty similar to the actor's router.&#xD;
&#xD;
&#xA0;&#xD;
<div>&#xD;
<div><strong>getAll</strong>: this function uses the Movie model to retrieve all the documents</div>&#xD;
<div>&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">getAll: function (req, res) {&#xD;
    Movie.find(function (err, movies) {&#xD;
        if (err) return res.status(400).json(err);&#xD;
&#xD;
        res.json(movies);&#xD;
    });&#xD;
},</pre>&#xD;
</div>&#xD;
</div>&#xD;
&#xA0;&#xD;
&#xD;
<strong>createOne</strong>: this function creates a new movie document&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">createOne: function (req, res) {&#xD;
    let newMovieDetails = req.body;&#xD;
    newMovieDetails._id = new mongoose.Types.ObjectId();&#xD;
    Movie.create(newMovieDetails, function (err, movie) {&#xD;
        if (err) return res.status(400).json(err);&#xD;
&#xD;
        res.json(movie);&#xD;
    });&#xD;
},</pre>&#xD;
&#xA0;&#xD;
<div>&#xD;
<div>&#xD;
<div>&#xD;
<div><strong>getOne</strong>: this function uses Movie model to retrieve a document (a movie) using its _id</div>&#xD;
<div>&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">getOne: function (req, res) {&#xD;
    Movie.findOne({ _id: req.params.id })&#xD;
        .populate('actors')&#xD;
        .exec(function (err, movie) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
            if (!movie) return res.status(404).json();&#xD;
&#xD;
            res.json(movie);&#xD;
        });&#xD;
},</pre>&#xD;
</div>&#xD;
</div>&#xD;
</div>&#xD;
</div>&#xD;
&#xA0;&#xD;
<div><strong>updateOne&#xC2;&#xA0;</strong>and&#xC2;&#xA0;<strong>deleteOne&#xC2;&#xA0;</strong><strong>&#xC2;&#xA0;</strong>functions have the same concepts as their counterparts in '/router/actor.js'</div>&#xD;
&#xA0;&#xD;
&#xD;
The movie router&#xC2;&#xA0; './routers/movie.js' in one piece&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">var Actor = require('../models/actor');&#xD;
var Movie = require('../models/movie');&#xD;
const mongoose = require('mongoose');&#xD;
&#xD;
module.exports = {&#xD;
&#xD;
    getAll: function (req, res) {&#xD;
        Movie.find(function (err, movies) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
&#xD;
            res.json(movies);&#xD;
        });&#xD;
    },&#xD;
&#xD;
&#xD;
    createOne: function (req, res) {&#xD;
        let newMovieDetails = req.body;&#xD;
        newMovieDetails._id = new mongoose.Types.ObjectId();&#xD;
        Movie.create(newMovieDetails, function (err, movie) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
&#xD;
            res.json(movie);&#xD;
        });&#xD;
    },&#xD;
&#xD;
&#xD;
    getOne: function (req, res) {&#xD;
        Movie.findOne({ _id: req.params.id })&#xD;
            .populate('actors')&#xD;
            .exec(function (err, movie) {&#xD;
                if (err) return res.status(400).json(err);&#xD;
                if (!movie) return res.status(404).json();&#xD;
&#xD;
                res.json(movie);&#xD;
            });&#xD;
    },&#xD;
&#xD;
&#xD;
    updateOne: function (req, res) {&#xD;
        Movie.findOneAndUpdate({ _id: req.params.id }, req.body, function (err, movie) {&#xD;
            if (err) return res.status(400).json(err);&#xD;
            if (!movie) return res.status(404).json();&#xD;
&#xD;
            res.json(movie);&#xD;
        });&#xD;
    }&#xD;
};</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now, it's time to implement app.js, which is the server-side.&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
References to the required packages:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const express = require('express');&#xD;
const mongoose = require('mongoose');</pre>&#xD;
&#xA0;&#xD;
&#xD;
References to the routers:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const actors = require('./routers/actor');&#xD;
const movies = require('./routers/movie');</pre>&#xD;
&#xA0;&#xD;
&#xD;
Create an app from Expressjs and configure it:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">const app = express();&#xD;
&#xD;
app.listen(8080);&#xD;
&#xD;
app.use(express.json());&#xD;
app.use(express.urlencoded({ extended: false }));</pre>&#xD;
&#xA0;&#xD;
&#xD;
Ask mongoose to connect to a database named 'movies' :&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">mongoose.connect('mongodb://localhost:27017/movies', function (err) {&#xD;
    if (err) {&#xD;
        return console.log('Mongoose - connection error:', err);&#xD;
    }&#xD;
    console.log('Connect Successfully');&#xD;
&#xD;
});</pre>&#xD;
&#xA0;&#xD;
&#xD;
Now, its time to create the RESTFul endpoints.&#xD;
<ul><li>If a GET request arrives with pathname ='/actors', execute actor.getAll</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">app.get('/actors', actors.getAll);&#xD;
</pre>&#xD;
<ul><li>If a POST request arrives with pathname ='/actors', execute actor.createOne</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">app.post('/actors', actors.createOne);&#xD;
</pre>&#xD;
<ul><li>If a GET request arrives with pathname ='/actors/:id', where <strong>id</strong> is the ID of the actor,&#xC2;&#xA0; execute actor.getOne</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">app.get('/actors/:id', actors.getOne);&#xD;
</pre>&#xD;
<ul><li>If a PUT request arrives with pathname ='/actors/:id', where <strong>id</strong> is the ID of the actor,&#xC2;&#xA0; execute actor.updateOne</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">app.put('/actors/:id', actors.updateOne);&#xD;
</pre>&#xD;
<ul><li>if a DELETE&#xC2;&#xA0;request arrives with pathname ='/actors/:id', where <strong>id</strong> is the ID of the actor,&#xC2;&#xA0; execute actor.deleteOne</li>&#xD;
</ul><pre class="EnlighterJSRAW" style="padding-left: 60px;" data-enlighter-language="js">app.delete('/actors/:id', actors.deleteOne);&#xD;
</pre>&#xD;
&#xA0;&#xD;
&#xD;
the RESTFul endpoints for the Movie Schema have the same concepts as their counterparts in Actor&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
So, the app.js in one piece:&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="null">//https://hub.packtpub.com/building-movie-api-express/&#xD;
const express = require('express');&#xD;
const mongoose = require('mongoose');&#xD;
&#xD;
const actors = require('./routers/actor');&#xD;
const movies = require('./routers/movie');&#xD;
&#xD;
const app = express();&#xD;
&#xD;
app.listen(8080);&#xD;
&#xD;
&#xD;
app.use(express.json());&#xD;
app.use(express.urlencoded({ extended: false }));&#xD;
&#xD;
mongoose.connect('mongodb://localhost:27017/movies', function (err) {&#xD;
    if (err) {&#xD;
        return console.log('Mongoose - connection error:', err);&#xD;
    }&#xD;
    console.log('Connect Successfully');&#xD;
&#xD;
});&#xD;
&#xD;
//Configuring Endpoints&#xD;
//Actor RESTFul endpoionts &#xD;
app.get('/actors', actors.getAll);&#xD;
app.post('/actors', actors.createOne);&#xD;
app.get('/actors/:id', actors.getOne);&#xD;
app.put('/actors/:id', actors.updateOne);&#xD;
app.post('/actors/:id/movies', actors.addMovie);&#xD;
app.delete('/actors/:id', actors.deleteOne);&#xD;
&#xD;
&#xD;
//Movie RESTFul  endpoints&#xD;
app.get('/movies', movies.getAll);&#xD;
app.post('/movies', movies.createOne);&#xD;
app.get('/movies/:id', movies.getOne);&#xD;
app.put('/movies/:id', movies.updateOne);&#xD;
</pre>&#xD;
<h2/>&#xD;
<h2/>&#xD;
<h2>Testing RESTFul Applications</h2>&#xD;
There are several ways to test the RESTFul applications. The first approach is to develop frontend pages that generate HTTP requests (what we have done in the previous weeks). This approach is not generic and flexible enough to test many cases and it needs a lot of time and resources. The second approach is using RESTFul clients that simulate the client-side and generate requests based on our design. This section demonstrates how to install and use Postman RESTFul client plugin.&#xD;
&#xD;
Postman is an application that enables developers to send HTTP requests to servers.&#xD;
&#xD;
To install Postman as a native app on your machine, navigate to&#xC2;&#xA0;<a href="https://www.getpostman.com/downloads/">https://www.getpostman.com/downloads/</a>&#xD;
&#xD;
Now, open Postman and Select Request.&#xD;
&#xD;
The below picture depicts the required&#xC2;&#xA0;settings to send a POST request with URL <strong>http://localhost:8080/actors</strong> and a body in JSON format:&#xD;
&#xD;
<a href="https://www.alexandriarepository.org/media/sendpostrequestjson" rel="attachment wp-att-161573"><img class="wp-image-161573 aligncenter" src="./assets/sendpostrequestjson.png" alt="" width="817" height="463"/></a>&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
&#xA0;&#xD;
&#xD;
The same post request but the body in urlencoded format:&#xD;
&#xD;
<a href="https://www.alexandriarepository.org/media/sendrequesturlencoded" rel="attachment wp-att-161574"><img class="wp-image-161574 aligncenter" src="./assets/sendrequesturlencoded.png" alt="" width="852" height="401"/></a>&#xD;
&#xD;
&#xA0;&#xD;
<blockquote>Remember, our express app is configured to understand both formats:JSON and urlencoded&#xD;
<pre class="EnlighterJSRAW" data-enlighter-language="js">app.use(express.json());&#xD;
app.use(express.urlencoded({ extended: false }));</pre>&#xD;
&#xA0;</blockquote>&#xD;
&#xA0;&#xD;
&#xD;
to send a delete request:&#xD;
&#xD;
<a href="https://www.alexandriarepository.org/media/delete-3" rel="attachment wp-att-161576"><img class="wp-image-161576 aligncenter" src="./assets/delete-1.png" alt="" width="1105" height="350"/></a>&#xD;
<h4/>&#xD;
<h2>Postman: How to use?</h2>&#xD;
<video controls width="1552" height="1080"><source src="./assets/postman2.mp4" type="video/mp4"/></video></body></html>
